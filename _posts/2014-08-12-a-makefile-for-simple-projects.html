---
layout: post
title: A Makefile for simple projects
date: '2014-08-12T15:31:00.000-07:00'
author: "@eamoc"
tags: 
modified_time: '2019-01-28T03:16:33.707-08:00'
blogger_id: tag:blogger.com,1999:blog-6955428370236550107.post-1465253185577232219
blogger_orig_url: https://eamoc.blogspot.com/2014/08/a-makefile-for-simple-projects.html
---

So I've been working on a simple C++ project which requires the following command to build:<br /><br /><b>g++ -Wall -o game game.cpp main.cpp -lncurses -I.</b><br /><br /><br /><i>game</i> is the output executable, <i>game.*</i> and <i>main.cpp</i> are the source files and <i>ncurses</i> is a library whuch must be linked in with the <b>-l</b> switch. The <b>-I</b> switch along with the <b>dot</b>, will cause g++ to look in the current directory for <i>game.h</i>. The <b>-Wall</b> switch (short for Warning all) tells the compiler to output all possible warnings if any.<br />If I change just one source file, I have to recompile the whole lot, this can be extremely time consuming. Obviously this method of building software is not very flexible, and can be seriously cumbersome as the project increases in size and complexity. <br />Enter makefiles.....<br /><br />If I create a file called 'makefile', and put it in the sourcefile directory with the following:<br /><br /><b>game: game.cpp main.cpp</b><br /><b>g++ -Wall -o game game.cpp game.h main.cpp -lncurses</b><br /><br />then all I need to do in type '<b>make</b>' at the command line instead of using the up arrow on the keyboard all the time.<br /><br />The first line in the makefile specifies the target. Usually you would specify the target you want to run with make, so you would do make game, but in this case we have only one target, so make will just go for the first one on the list.<br /><br />After the target name and semicolon you specify the files that need to be compiled if any of them change, in this case game.cpp and main.cpp<br />This solves the problem of having to recompile all the source files each time because make now knows to just compile the source files that have changed.<br />Finally its important to note that make requires a tab to be inserted before the compiler command. Make requires a tab to be in place before any command, and will get cranky if it isn't there.<br /><br />The is fine but we could do with being a little more specific and succinct in how we instruct the compiler. First of all we can define some macros. <br /><br />We define CC as referring the the compiler we are using, then we define a macro CXXFLAGS to specify all the switches we use in the command, next is the DEPS macro, which lists all the header files, that the .cpp files depend on. Finally we have LIBS, which specifies the library or librtaries that we include when we link.<br /><br /><b>CC=g++</b><br /><b>CXXFLAGS=-I.</b><br /><b>DEPS = game.h</b><br /><b>LIBS=-lncurses</b><br /><br />Now we generalize the syntax of our command to make it more portable.<br />We create<br /><b><br /></b><b>%.o: %.cpp $(DEPS)</b><br /><b>$(CC) -c -o $@ $&lt; $(CXXFLAGS)</b><br /><br /><br /><b>game: $(OBJ)</b><br /><b>$(CC) -o $@ $^ $(CXXFLAGS) $(LIBS)</b><br /><br />The first target is the compile stage, an instruction to g++ to compile all the cpp files. Our target here is '%.o' and the dependencies are '%.cpp' and '$(DEPS)', i.e. game.h in this case.<br />The second line is the command to be issued. The first term in the command is the dereferenced CC macro, i.e. g++, then we have the -c switch to compile only, the -o switch to specify the output file, which is '$@' (that which is specified on the left side of the semicolon, in this case %.o) then the files to be compiled, '$&lt;' (that which is specified on the left side of the semicolon, in this case %.o)and finally $(CXXFLAGS). <br /><br />The second target, is the link stage, where it takes the object files created in the compile stage and generates the executable file, game in this case. Its pretty much the same as the compile stage except the '-c' switch is ommitted as we want to link the files. Also, the LIBS macro is dereferenced here as we want to linnk ht encurses library.<br /><br />So thats cool, we now have a set up where we can build the files using a simple command, make, we can easily add additional libraries if needs be, and for neatness we have separated out he compile and link stages. But we can refine this further. We might like to put the source and header files in separate directories, we might also want to clean out all unwanted intermediary files like object files etc.<br /><br />So to do this we will lay out a simple project directory structure. If we want to create a project called testproj1, then we create that directory and everything will go inside it. The source files go into a directory called 'src' and the header files go into 'include'. The object files will go into 'obj', which will be a subdirectory under 'src'. We will also have a target 'clean' which removes all the object files etc.<br /><br /><b>IDIR =../include</b><br /><b>CC=g++</b><br /><b>CXXFLAGS=-I$(IDIR)</b><br /><b>ODIR=obj</b><br /><b>LIBS=-lncurses</b><br /><b><br /></b><b>_DEPS = game.h</b><br /><b>DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))</b><br /><b><br /></b><b>_OBJ = game.o main.o </b><br /><b>OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))</b><br /><b><br /></b><b><br /></b><b>$(ODIR)/%.o: %.c $(DEPS)</b><br /><b>$(CC) -c -o $@ $&lt; $(CFLAGS)</b><br /><b><br /></b><b>game: $(OBJ)</b><br /><b>gcc -o $@ $^ $(CFLAGS) $(LIBS)</b><br /><b><br /></b><b>#This is just to stop make trying to do something with a file called 'clean'</b><br /><b>.PHONY: clean</b><br /><b><br /></b><b>clean:</b><br /><b>rm -f $(ODIR)/*.o *~ core $(INCDIR)/*~ </b><br /><br />This will do for now....Really need to have the makefile at the project root as well as the executable binary.<br />Also need to create a bash script that will set up the project directories and generate the makefile automatically<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />